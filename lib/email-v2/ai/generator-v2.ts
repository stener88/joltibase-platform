/**
 * Semantic Email Generator (V2)
 * 
 * Generates emails using semantic blocks approach:
 * 1. AI generates semantic content blocks (hero, features, etc.)
 * 2. Transform functions convert blocks to React Email components
 * 
 * This ensures no empty Sections and deterministic structure
 */

import type { EmailComponent, GlobalEmailSettings } from '../types';
import { EmailContentSchema, createEmailContentSchema, getMaxBlocksForCampaign, type EmailContent } from './blocks';

import { renderEmailComponent } from '../renderer';
import { fetchImagesForBlocks } from './image-fetcher';
import { replaceImageKeywords, addCreditsToFooter } from './image-helpers';

import { transformBlocksToEmail } from './transforms';

/**
 * Calculate token cost for Gemini models
 * Pricing as of Nov 2024: https://ai.google.dev/pricing
 */
function calculateTokenCost(model: string, usage: any): { inputCost: number; outputCost: number; totalCost: number } {
  const inputTokens = usage?.promptTokens || usage?.inputTokens || 0;
  const outputTokens = usage?.completionTokens || usage?.outputTokens || 0;
  
  // Pricing per 1M tokens (in USD)
  let inputPricePer1M = 0;
  let outputPricePer1M = 0;
  
  if (model.includes('2.5-flash')) {
    // Gemini 2.5 Flash: $0.10/$0.40 per 1M tokens (input/output)
    inputPricePer1M = 0.10;
    outputPricePer1M = 0.40;
  } else if (model.includes('2.0-flash')) {
    // Gemini 2.0 Flash: Free tier
    inputPricePer1M = 0;
    outputPricePer1M = 0;
  } else if (model.includes('1.5-flash')) {
    // Gemini 1.5 Flash: $0.075/$0.30 per 1M tokens
    inputPricePer1M = 0.075;
    outputPricePer1M = 0.30;
  } else if (model.includes('1.5-pro')) {
    // Gemini 1.5 Pro: $1.25/$5.00 per 1M tokens
    inputPricePer1M = 1.25;
    outputPricePer1M = 5.00;
  }
  
  const inputCost = (inputTokens / 1_000_000) * inputPricePer1M;
  const outputCost = (outputTokens / 1_000_000) * outputPricePer1M;
  const totalCost = inputCost + outputCost;
  
  return { inputCost, outputCost, totalCost };
}

/**
 * Generation options
 */
export interface GenerationOptions {
  /** Temperature for AI generation (0-1) */
  temperature?: number;
  
  /** Model to use */
  model?: string;
  
  /** Email type for specialized prompting */
  emailType?: 'marketing' | 'transactional' | 'newsletter';
}

/**
 * Campaign-specific generation options
 */
export interface CampaignGenerationOptions extends GenerationOptions {
  /** Campaign name */
  campaignName?: string;
  
  /** Campaign type */
  campaignType?: 'one-time' | 'sequence' | 'newsletter';
  
  /** Company name for branding */
  companyName?: string;
  
  /** Target audience description */
  targetAudience?: string;
  
  /** Structure hints from prompt analysis */
  structureHints?: {
    gridLayout?: { columns: number; rows: number };
    itemCount?: number;
    needsTable?: boolean;
    needsLogo?: boolean;
  };
  
  /** Tone for content generation */
  tone?: 'formal' | 'casual' | 'friendly' | 'professional' | 'urgent' | 'playful';
  
  /** Content type for structure guidance */
  contentType?: 'press-release' | 'announcement' | 'sale' | 'update' | 'story' | 'product-launch' | 'event' | 'newsletter' | 'transactional';
}

/**
 * Generation result with metadata
 */
export interface GenerationResult {
  /** Semantic blocks generated by AI */
  blocks: EmailContent;
  
  /** Rendered HTML */
  html: string;
  
  /** EmailComponent tree for editor */
  rootComponent: EmailComponent;
  
  /** Generation metadata */
  metadata: {
    model: string;
    tokens: number;
    timeMs: number;
    blocksGenerated: number;
    photoCredits?: string[];
  };
}

/**
 * Campaign-level metadata extracted from generation
 */
export interface CampaignMetadata {
  /** Suggested campaign name */
  campaignName: string;
  
  /** Recommended audience segment */
  recommendedSegment: string;
  
  /** Suggested send time */
  sendTimeSuggestion: string;
}

/**
 * Campaign generation result with campaign metadata
 */
export interface CampaignGenerationResult extends GenerationResult {
  /** Campaign-specific metadata */
  campaignMetadata: CampaignMetadata;
}

/**
 * Generate semantic email content blocks from user prompt
 * 
 * Uses two-pass generation to avoid schema complexity errors:
 * - Pass 1: Generate structure (block types + order)
 * - Pass 2: Generate content for each block individually
 * 
 * @param prompt - User's natural language prompt
 * @param settings - Global email settings (colors, fonts, etc.)
 * @param options - Generation options
 * @returns EmailContent with semantic blocks
 */
export async function generateSemanticBlocks(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<{ content: EmailContent; usage: any }> {
  const startTime = Date.now();
  
  const {
    model = 'gemini-2.5-flash',
    emailType,
    campaignType,
    structureHints,
  } = options;
  
  console.log('ü§ñ [SEMANTIC-GEN] Using two-pass generation');
  console.log('üìù [SEMANTIC-GEN] Prompt:', prompt);
  console.log('üìß [SEMANTIC-GEN] Email type:', emailType || 'auto');
  console.log('‚öôÔ∏è  [SEMANTIC-GEN] Model:', model);
  
  try {
    // Import and use two-pass generator
    const { generateSemanticBlocks: twoPassGenerator } = await import('./generator-two-pass');
    
    const result = await twoPassGenerator(
      prompt,
      settings,
      emailType || campaignType || 'newsletter',
      structureHints || {},
      model
    );
    
    const timeMs = Date.now() - startTime;
    
    console.log('‚úÖ [SEMANTIC-GEN] Content generated successfully');
    console.log(`‚è±Ô∏è  [SEMANTIC-GEN] Time: ${timeMs}ms`);
    console.log(`üì¶ [SEMANTIC-GEN] Blocks: ${result.blocks.length}`);
    
    // Log block types for debugging
    const blockTypes = result.blocks.map(b => b.blockType);
    console.log(`üéØ [SEMANTIC-GEN] Block types: ${blockTypes.join(', ')}`);
    
    // Validate we have essential blocks
    const hasFooter = result.blocks.some(b => b.blockType === 'footer');
    
    return {
      content: {
        previewText: result.previewText,
        blocks: result.blocks,
      },
      usage: result.usage || {},
    };
    
    if (!hasFooter) {
      console.warn('‚ö†Ô∏è  [SEMANTIC-GEN] Warning: No footer block generated');
    }
    
    // Return with usage data from two-pass generator
    return { 
      content: {
        previewText: result.previewText,
        blocks: result.blocks,
      },
      usage: result.usage || {
        totalTokens: 0,
        promptTokens: 0,
        completionTokens: 0,
      }
    };
    
  } catch (error) {
    console.error('‚ùå [SEMANTIC-GEN] Generation failed:', error);
    
    if (error instanceof Error) {
      throw new Error(`Semantic generation failed: ${error.message}`);
    }
    throw new Error('Semantic generation failed: Unknown error');
  }
}

/**
 * Generate complete email with semantic blocks approach
 * 
 * Full pipeline:
 * 1. AI generates semantic content blocks
 * 2. Render patterns directly to HTML
 * 3. Return blocks + HTML (no EmailComponent intermediate)
 * 
 * @param prompt - User's natural language prompt
 * @param settings - Global email settings
 * @param options - Generation options
 * @returns Semantic blocks and rendered HTML
 */
export async function generateEmailSemantic(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<GenerationResult> {
  const startTime = Date.now();
  
  console.log('üöÄ [EMAIL-GEN-V2] Starting semantic email generation');
  
  // Phase 1: Generate semantic content blocks
  const { content, usage } = await generateSemanticBlocks(prompt, settings, options);
  
  // Phase 2: Fetch images from Unsplash (or fallback to picsum.photos)
  console.log('üñºÔ∏è  [EMAIL-GEN-V2] Fetching images from Unsplash');
  const { imageMap, credits } = await fetchImagesForBlocks(content.blocks);
  
  // Phase 3: Replace keywords with URLs
  console.log('üîÑ [EMAIL-GEN-V2] Replacing image keywords with URLs');
  let blocksWithImages = replaceImageKeywords(content.blocks, imageMap);
  
  
  
  // Phase 4: Add photo credits to footer
  if (credits.length > 0) {
    console.log(`üì∏ [EMAIL-GEN-V2] Adding ${credits.length} photo credits to footer`);
    blocksWithImages = addCreditsToFooter(blocksWithImages, credits);
  }
  
  // Phase 5: Generate EmailComponent tree directly (no template engine needed!)
  console.log('üå≥ [EMAIL-GEN-V2] Generating EmailComponent tree directly');
  const components = transformBlocksToEmail(blocksWithImages, settings);
  
  // Wrap components in root structure with Container (standard 600px email width)
  const rootComponent: EmailComponent = {
    id: 'root',
    component: 'Html',
    props: { lang: 'en' },
    children: [
      {
        id: 'head',
        component: 'Head',
        props: {},
        children: content.previewText ? [{
          id: 'preview',
          component: 'Preview',
          props: {},
          content: content.previewText
        }] : undefined,
      },
      {
        id: 'body',
        component: 'Body',
        props: {
          style: {
            fontFamily: settings.fontFamily,
            backgroundColor: settings.backgroundColor || '#ffffff',
            margin: 0,
            padding: 0,
          }
        },
        children: [
          {
            id: 'main-container',
            component: 'Container',
            props: {
              style: {
                maxWidth: settings.maxWidth || '600px',
                margin: '0 auto',
              },
            },
            children: components,
          },
        ],
      },
    ],
  };
  
  console.log('‚úÖ [EMAIL-GEN-V2] EmailComponent tree generated');
  
  // Phase 6: Render EmailComponent to HTML (single source of truth)
  console.log('üîÑ [EMAIL-GEN-V2] Rendering EmailComponent to HTML');
  const { html } = await renderEmailComponent(rootComponent, settings);
  
  console.log(`‚úÖ [EMAIL-GEN-V2] Rendered ${blocksWithImages.length} blocks to HTML`);
  
  const timeMs = Date.now() - startTime;
  
  console.log('‚úÖ [EMAIL-GEN-V2] Email generation complete');
  console.log(`‚è±Ô∏è  [EMAIL-GEN-V2] Total time: ${timeMs}ms`);
  
  return {
    blocks: {
      ...content,
      blocks: blocksWithImages,
    },
    html,
    rootComponent,
    metadata: {
      model: options.model || 'gemini-2.5-flash',
      tokens: usage?.totalTokens || 0,
      timeMs,
      blocksGenerated: blocksWithImages.length,
      photoCredits: credits,
    },
  };
}

/**
 * Extract campaign metadata from prompt and context
 * 
 * Generates intelligent suggestions for campaign management
 * 
 * @param prompt - User's campaign prompt
 * @param options - Campaign generation options
 * @returns Campaign metadata with recommendations
 */
function extractCampaignMetadata(
  prompt: string,
  options: CampaignGenerationOptions
): CampaignMetadata {
  // Extract campaign name from options or generate from prompt
  const campaignName = options.campaignName || 
    `Campaign - ${new Date().toLocaleDateString()}`;
  
  // Determine recommended segment based on campaign type and audience
  let recommendedSegment = 'all_contacts';
  if (options.targetAudience) {
    const audience = options.targetAudience.toLowerCase();
    if (audience.includes('new') || audience.includes('trial')) {
      recommendedSegment = 'new_users';
    } else if (audience.includes('active') || audience.includes('engaged')) {
      recommendedSegment = 'active_users';
    } else if (audience.includes('premium') || audience.includes('paid')) {
      recommendedSegment = 'premium_users';
    } else if (audience.includes('inactive') || audience.includes('churn')) {
      recommendedSegment = 'inactive_users';
    }
  }
  
  // Suggest optimal send time based on campaign type
  let sendTimeSuggestion = 'Tuesday 10am local time';
  if (options.campaignType === 'newsletter') {
    sendTimeSuggestion = 'Thursday 9am local time';
  } else if (options.emailType === 'transactional') {
    sendTimeSuggestion = 'Immediate (transactional)';
  } else if (prompt.toLowerCase().includes('weekend') || prompt.toLowerCase().includes('friday')) {
    sendTimeSuggestion = 'Friday 11am local time';
  }
  
  return {
    campaignName,
    recommendedSegment,
    sendTimeSuggestion,
  };
}

/**
 * Generate complete V2 campaign with semantic blocks and campaign metadata
 * 
 * This is the main entry point for V2 campaign generation. It extends
 * generateEmailSemantic() with campaign-specific features:
 * - Campaign metadata extraction (name, segment, send time)
 * - Campaign type context (one-time, sequence, newsletter)
 * - Target audience and company branding
 * 
 * @param prompt - User's campaign prompt
 * @param settings - Global email settings (colors, fonts, etc.)
 * @param options - Campaign-specific options
 * @returns Complete campaign with email and metadata
 */
export async function generateCampaignV2(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<CampaignGenerationResult> {
  console.log('üöÄ [CAMPAIGN-GEN-V2] Starting V2 campaign generation');
  console.log('üìù [CAMPAIGN-GEN-V2] Campaign type:', options.campaignType || 'one-time');
  console.log('üè¢ [CAMPAIGN-GEN-V2] Company:', options.companyName || 'N/A');
  console.log('üë• [CAMPAIGN-GEN-V2] Audience:', options.targetAudience || 'general');
  
  // Generate email using semantic blocks approach
  const emailResult = await generateEmailSemantic(prompt, settings, {
    temperature: options.temperature,
    model: options.model,
    emailType: options.emailType,
  });
  
  console.log('‚úÖ [CAMPAIGN-GEN-V2] Email generated successfully');
  
  // Extract campaign-level metadata from prompt/context
  const campaignMetadata = extractCampaignMetadata(prompt, options);
  
  console.log('üìä [CAMPAIGN-GEN-V2] Campaign metadata:', {
    name: campaignMetadata.campaignName,
    segment: campaignMetadata.recommendedSegment,
    sendTime: campaignMetadata.sendTimeSuggestion,
  });
  
  console.log('‚úÖ [CAMPAIGN-GEN-V2] Campaign generation complete');
  
  return {
    ...emailResult,
    campaignMetadata,
  };
}

/**
 * Test the semantic generator with a simple prompt
 */
export async function testSemanticGenerator(): Promise<void> {
  const testPrompt = 'Create a welcome email for a productivity SaaS app';
  const testSettings: GlobalEmailSettings = {
    primaryColor: '#7c3aed',
    fontFamily: 'system-ui, sans-serif',
    maxWidth: '600px',
  };
  
  console.log('\nüß™ Testing Semantic Email Generator...\n');
  
  try {
    const result = await generateEmailSemantic(testPrompt, testSettings, {
      emailType: 'marketing',
    });
    
    console.log('\n‚úÖ Semantic generator test passed!');
    console.log('Generated email with', result.metadata.blocksGenerated, 'blocks');
    console.log('Total time:', result.metadata.timeMs, 'ms');
    console.log('Total tokens:', result.metadata.tokens);
    
  } catch (error) {
    console.error('\n‚ùå Semantic generator test failed:', error);
    throw error;
  }
}

