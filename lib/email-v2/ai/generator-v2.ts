/**
 * Semantic Email Generator (V2)
 * 
 * Generates emails using semantic blocks approach:
 * 1. AI generates semantic content blocks (hero, features, etc.)
 * 2. Transform functions convert blocks to React Email components
 * 
 * This ensures no empty Sections and deterministic structure
 */

import { generateObject } from 'ai';
import { createGoogleGenerativeAI } from '@ai-sdk/google';
import type { EmailComponent, GlobalEmailSettings } from '../types';
import { EmailContentSchema, createEmailContentSchema, getMaxBlocksForCampaign, type EmailContent } from './blocks';
import { buildSemanticGenerationPrompt } from './prompts-v2';
import { renderPatternsToEmail } from '../pattern-renderer';
import { fetchImagesForBlocks } from './image-fetcher';
import { replaceImageKeywords, addCreditsToFooter } from './image-helpers';
import { enforceColorConsistency } from './color-enforcer';

// Initialize Google AI with API key
const getGoogleModel = (model: string) => {
  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_GENERATIVE_AI_API_KEY;
  if (!apiKey) {
    throw new Error('GEMINI_API_KEY or GOOGLE_GENERATIVE_AI_API_KEY environment variable is not set');
  }
  
  const google = createGoogleGenerativeAI({ apiKey });
  return google(model);
};

/**
 * Calculate token cost for Gemini models
 * Pricing as of Nov 2024: https://ai.google.dev/pricing
 */
function calculateTokenCost(model: string, usage: any): { inputCost: number; outputCost: number; totalCost: number } {
  const inputTokens = usage?.promptTokens || usage?.inputTokens || 0;
  const outputTokens = usage?.completionTokens || usage?.outputTokens || 0;
  
  // Pricing per 1M tokens (in USD)
  let inputPricePer1M = 0;
  let outputPricePer1M = 0;
  
  if (model.includes('2.5-flash')) {
    // Gemini 2.5 Flash: $0.10/$0.40 per 1M tokens (input/output)
    inputPricePer1M = 0.10;
    outputPricePer1M = 0.40;
  } else if (model.includes('2.0-flash')) {
    // Gemini 2.0 Flash: Free tier
    inputPricePer1M = 0;
    outputPricePer1M = 0;
  } else if (model.includes('1.5-flash')) {
    // Gemini 1.5 Flash: $0.075/$0.30 per 1M tokens
    inputPricePer1M = 0.075;
    outputPricePer1M = 0.30;
  } else if (model.includes('1.5-pro')) {
    // Gemini 1.5 Pro: $1.25/$5.00 per 1M tokens
    inputPricePer1M = 1.25;
    outputPricePer1M = 5.00;
  }
  
  const inputCost = (inputTokens / 1_000_000) * inputPricePer1M;
  const outputCost = (outputTokens / 1_000_000) * outputPricePer1M;
  const totalCost = inputCost + outputCost;
  
  return { inputCost, outputCost, totalCost };
}

/**
 * Generation options
 */
export interface GenerationOptions {
  /** Temperature for AI generation (0-1) */
  temperature?: number;
  
  /** Model to use */
  model?: string;
  
  /** Email type for specialized prompting */
  emailType?: 'marketing' | 'transactional' | 'newsletter';
}

/**
 * Campaign-specific generation options
 */
export interface CampaignGenerationOptions extends GenerationOptions {
  /** Campaign name */
  campaignName?: string;
  
  /** Campaign type */
  campaignType?: 'one-time' | 'sequence' | 'newsletter';
  
  /** Company name for branding */
  companyName?: string;
  
  /** Target audience description */
  targetAudience?: string;
}

/**
 * Generation result with metadata
 */
export interface GenerationResult {
  /** Semantic blocks generated by AI */
  blocks: EmailContent;
  
  /** Rendered HTML */
  html: string;
  
  /** Generation metadata */
  metadata: {
    model: string;
    tokens: number;
    timeMs: number;
    blocksGenerated: number;
    photoCredits?: string[];
  };
}

/**
 * Campaign-level metadata extracted from generation
 */
export interface CampaignMetadata {
  /** Suggested campaign name */
  campaignName: string;
  
  /** Recommended audience segment */
  recommendedSegment: string;
  
  /** Suggested send time */
  sendTimeSuggestion: string;
}

/**
 * Campaign generation result with campaign metadata
 */
export interface CampaignGenerationResult extends GenerationResult {
  /** Campaign-specific metadata */
  campaignMetadata: CampaignMetadata;
}

/**
 * Generate semantic email content blocks from user prompt
 * 
 * Phase 1: AI generates semantic blocks (hero, features, cta, footer, etc.)
 * This is the core semantic generation that replaces direct component generation
 * 
 * @param prompt - User's natural language prompt
 * @param settings - Global email settings (colors, fonts, etc.)
 * @param options - Generation options
 * @returns EmailContent with semantic blocks
 */
export async function generateSemanticBlocks(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<{ content: EmailContent; usage: any }> {
  const startTime = Date.now();
  
  const {
    temperature = 0.5,
    model = 'gemini-2.5-flash',
    emailType,
    campaignType,
    companyName,
    targetAudience,
  } = options;
  
  // Determine max blocks based on campaign type and prompt content
  const maxBlocks = getMaxBlocksForCampaign(campaignType, prompt);
  const dynamicSchema = createEmailContentSchema(maxBlocks);
  
  console.log('ü§ñ [SEMANTIC-GEN] Generating semantic content blocks');
  console.log('üìù [SEMANTIC-GEN] Prompt:', prompt);
  console.log('üìß [SEMANTIC-GEN] Email type:', emailType || 'auto');
  console.log('üì¶ [SEMANTIC-GEN] Max blocks:', maxBlocks);
  console.log('‚öôÔ∏è  [SEMANTIC-GEN] Model:', model);
  
  try {
    const { object, usage } = await generateObject({
      model: getGoogleModel(model),
      schema: dynamicSchema,
      prompt: buildSemanticGenerationPrompt(prompt, settings, emailType, {
        campaignType,
        companyName,
        targetAudience,
      }),
      temperature,
    });
    
    const timeMs = Date.now() - startTime;
    
    // Calculate cost
    const cost = calculateTokenCost(model, usage);
    const usageAny = usage as any;
    const inputTokens = usageAny?.promptTokens || usageAny?.inputTokens || 0;
    const outputTokens = usageAny?.completionTokens || usageAny?.outputTokens || 0;
    
    console.log('‚úÖ [SEMANTIC-GEN] Content generated successfully');
    console.log(`üìä [SEMANTIC-GEN] Tokens: ${usage?.totalTokens || 'unknown'} (in: ${inputTokens}, out: ${outputTokens})`);
    console.log(`üí∞ [SEMANTIC-GEN] Cost: $${cost.totalCost.toFixed(6)} (in: $${cost.inputCost.toFixed(6)}, out: $${cost.outputCost.toFixed(6)})`);
    console.log(`‚è±Ô∏è  [SEMANTIC-GEN] Time: ${timeMs}ms`);
    console.log(`üì¶ [SEMANTIC-GEN] Blocks: ${object.blocks.length}`);
    
    // Log block types for debugging
    const blockTypes = object.blocks.map(b => b.blockType);
    console.log(`üéØ [SEMANTIC-GEN] Block types: ${blockTypes.join(', ')}`);
    
    // Validate we have essential blocks
    const hasFooter = object.blocks.some(b => b.blockType === 'footer');
    if (!hasFooter) {
      console.warn('‚ö†Ô∏è  [SEMANTIC-GEN] Warning: No footer block generated');
    }
    
    return { content: object, usage };
    
  } catch (error) {
    console.error('‚ùå [SEMANTIC-GEN] Generation failed:', error);
    
    if (error instanceof Error) {
      throw new Error(`Semantic generation failed: ${error.message}`);
    }
    throw new Error('Semantic generation failed: Unknown error');
  }
}

/**
 * Generate complete email with semantic blocks approach
 * 
 * Full pipeline:
 * 1. AI generates semantic content blocks
 * 2. Render patterns directly to HTML
 * 3. Return blocks + HTML (no EmailComponent intermediate)
 * 
 * @param prompt - User's natural language prompt
 * @param settings - Global email settings
 * @param options - Generation options
 * @returns Semantic blocks and rendered HTML
 */
export async function generateEmailSemantic(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<GenerationResult> {
  const startTime = Date.now();
  
  console.log('üöÄ [EMAIL-GEN-V2] Starting semantic email generation');
  
  // Phase 1: Generate semantic content blocks
  const { content, usage } = await generateSemanticBlocks(prompt, settings, options);
  
  // Phase 2: Fetch images from Unsplash (or fallback to picsum.photos)
  console.log('üñºÔ∏è  [EMAIL-GEN-V2] Fetching images from Unsplash');
  const { imageMap, credits } = await fetchImagesForBlocks(content.blocks);
  
  // Phase 3: Replace keywords with URLs
  console.log('üîÑ [EMAIL-GEN-V2] Replacing image keywords with URLs');
  let blocksWithImages = replaceImageKeywords(content.blocks, imageMap);
  
  // Phase 3.5: Enforce color consistency
  blocksWithImages = enforceColorConsistency(blocksWithImages, settings.primaryColor);
  
  // Phase 4: Add photo credits to footer
  if (credits.length > 0) {
    console.log(`üì∏ [EMAIL-GEN-V2] Adding ${credits.length} photo credits to footer`);
    blocksWithImages = addCreditsToFooter(blocksWithImages, credits);
  }
  
  // Phase 5: Render patterns directly to HTML
  console.log('üîÑ [EMAIL-GEN-V2] Rendering patterns directly to HTML');
  const html = await renderPatternsToEmail(blocksWithImages, settings, content.previewText);
  
  console.log(`‚úÖ [EMAIL-GEN-V2] Rendered ${blocksWithImages.length} blocks to HTML`);
  
  const timeMs = Date.now() - startTime;
  
  console.log('‚úÖ [EMAIL-GEN-V2] Email generation complete');
  console.log(`‚è±Ô∏è  [EMAIL-GEN-V2] Total time: ${timeMs}ms`);
  
  return {
    blocks: {
      ...content,
      blocks: blocksWithImages,
    },
    html,
    metadata: {
      model: options.model || 'gemini-2.5-flash',
      tokens: usage?.totalTokens || 0,
      timeMs,
      blocksGenerated: blocksWithImages.length,
      photoCredits: credits,
    },
  };
}

/**
 * Extract campaign metadata from prompt and context
 * 
 * Generates intelligent suggestions for campaign management
 * 
 * @param prompt - User's campaign prompt
 * @param options - Campaign generation options
 * @returns Campaign metadata with recommendations
 */
function extractCampaignMetadata(
  prompt: string,
  options: CampaignGenerationOptions
): CampaignMetadata {
  // Extract campaign name from options or generate from prompt
  const campaignName = options.campaignName || 
    `Campaign - ${new Date().toLocaleDateString()}`;
  
  // Determine recommended segment based on campaign type and audience
  let recommendedSegment = 'all_contacts';
  if (options.targetAudience) {
    const audience = options.targetAudience.toLowerCase();
    if (audience.includes('new') || audience.includes('trial')) {
      recommendedSegment = 'new_users';
    } else if (audience.includes('active') || audience.includes('engaged')) {
      recommendedSegment = 'active_users';
    } else if (audience.includes('premium') || audience.includes('paid')) {
      recommendedSegment = 'premium_users';
    } else if (audience.includes('inactive') || audience.includes('churn')) {
      recommendedSegment = 'inactive_users';
    }
  }
  
  // Suggest optimal send time based on campaign type
  let sendTimeSuggestion = 'Tuesday 10am local time';
  if (options.campaignType === 'newsletter') {
    sendTimeSuggestion = 'Thursday 9am local time';
  } else if (options.emailType === 'transactional') {
    sendTimeSuggestion = 'Immediate (transactional)';
  } else if (prompt.toLowerCase().includes('weekend') || prompt.toLowerCase().includes('friday')) {
    sendTimeSuggestion = 'Friday 11am local time';
  }
  
  return {
    campaignName,
    recommendedSegment,
    sendTimeSuggestion,
  };
}

/**
 * Generate complete V2 campaign with semantic blocks and campaign metadata
 * 
 * This is the main entry point for V2 campaign generation. It extends
 * generateEmailSemantic() with campaign-specific features:
 * - Campaign metadata extraction (name, segment, send time)
 * - Campaign type context (one-time, sequence, newsletter)
 * - Target audience and company branding
 * 
 * @param prompt - User's campaign prompt
 * @param settings - Global email settings (colors, fonts, etc.)
 * @param options - Campaign-specific options
 * @returns Complete campaign with email and metadata
 */
export async function generateCampaignV2(
  prompt: string,
  settings: GlobalEmailSettings,
  options: CampaignGenerationOptions = {}
): Promise<CampaignGenerationResult> {
  console.log('üöÄ [CAMPAIGN-GEN-V2] Starting V2 campaign generation');
  console.log('üìù [CAMPAIGN-GEN-V2] Campaign type:', options.campaignType || 'one-time');
  console.log('üè¢ [CAMPAIGN-GEN-V2] Company:', options.companyName || 'N/A');
  console.log('üë• [CAMPAIGN-GEN-V2] Audience:', options.targetAudience || 'general');
  
  // Generate email using semantic blocks approach
  const emailResult = await generateEmailSemantic(prompt, settings, {
    temperature: options.temperature,
    model: options.model,
    emailType: options.emailType,
  });
  
  console.log('‚úÖ [CAMPAIGN-GEN-V2] Email generated successfully');
  
  // Extract campaign-level metadata from prompt/context
  const campaignMetadata = extractCampaignMetadata(prompt, options);
  
  console.log('üìä [CAMPAIGN-GEN-V2] Campaign metadata:', {
    name: campaignMetadata.campaignName,
    segment: campaignMetadata.recommendedSegment,
    sendTime: campaignMetadata.sendTimeSuggestion,
  });
  
  console.log('‚úÖ [CAMPAIGN-GEN-V2] Campaign generation complete');
  
  return {
    ...emailResult,
    campaignMetadata,
  };
}

/**
 * Test the semantic generator with a simple prompt
 */
export async function testSemanticGenerator(): Promise<void> {
  const testPrompt = 'Create a welcome email for a productivity SaaS app';
  const testSettings: GlobalEmailSettings = {
    primaryColor: '#7c3aed',
    fontFamily: 'system-ui, sans-serif',
    maxWidth: '600px',
  };
  
  console.log('\nüß™ Testing Semantic Email Generator...\n');
  
  try {
    const result = await generateEmailSemantic(testPrompt, testSettings, {
      emailType: 'marketing',
    });
    
    console.log('\n‚úÖ Semantic generator test passed!');
    console.log('Generated email with', result.metadata.blocksGenerated, 'blocks');
    console.log('Total time:', result.metadata.timeMs, 'ms');
    console.log('Total tokens:', result.metadata.tokens);
    
  } catch (error) {
    console.error('\n‚ùå Semantic generator test failed:', error);
    throw error;
  }
}

